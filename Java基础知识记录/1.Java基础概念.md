## Java 语言有哪些特点?

- 简单易学；
- 面向对象（封装，继承，多态）；
- 平台无关性（ Java 虚拟机实现平台无关性）；
- 支持多线程；
- 可靠性；
- 安全性；
- 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
- 编译与解释并存

## JVM vs JDK vs JRE

- ### Jvm

  - Java 虚拟机（JVM）是运行 Java 字节码的虚拟机,JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果

- ### JDK

  - 功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

- ### JRE

  - JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序

## 字节码

- JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件），只面向虚拟机
-  JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行
  - 有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，
  - 因此引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译，
    - 当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用
  - JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销，但是便一直来比不上JIT

##  Java 语言“编译与解释并存”

- **编译型** ：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。
  - 一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
- **解释型** ：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。
  - 解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。
- Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

## Oracle JDK vs OpenJDK

- OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；
  - OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化
  - OpenJDK 是商业免费的。虽然 Oracle JDK 部分版本商业免费。
  - OpenJDK 更新频率更快
- Oracle JDK 比 OpenJDK 更稳定
- 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能

## JAVA和C++的区别

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

## 基本语法

- ### 字符型常量和字符串常量的区别

  - **形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
  - **含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
  - **占内存大小** ： 字符常量只占 2 个字节; 字符串常量占若干个字节。

- ### 标识符和关键字的区别

  - 标识符为程序、类、变量、方法等取名字

  - 关键字是被赋予特殊含义的标识符

    - `default` 很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制

      - 在程序控制中，当在 `switch` 中匹配不到任何情况时，可以使用 `default` 来编写默认匹配的情况。
      - 在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 `default` 关键字来定义一个方法的默认实现。
      - 在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 `default`，但是这个修饰符加上了就会报错。

    - | 分类                 | 关键字   |            |          |              |            |           |        |
      | :------------------- | :------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
      | 访问控制             | private  | protected  | public   |              |            |           |        |
      | 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
      |                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |
      | 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
      |                      | for      | instanceof | switch   | case         | default    | assert    |        |
      | 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
      | 包相关               | import   | package    |          |              |            |           |        |
      | 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
      |                      | short    |            |          |              |            |           |        |
      | 变量引用             | super    | this       | void     |              |            |           |        |
      | 保留字               | goto     | const      |          |              |            |           | 静态边 |

- ### 静态方法为什么不能调用非静态成员

  - 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。
  - 而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
  - 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作

- ###  静态方法和实例方法有何不同

  - #### 调用方式

    - 在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，
    - 而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。

  - #### 访问类成员是否存在限制

    - 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制

- ### 重载和重写的区别

  - 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
    - 重载发生在同一个类中（或者父类和子类之间），方法名必须相同，
    - 参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同
  - 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法
    - 方法名相同、形参列表相同；
    - 子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
    - 子类方法的访问权限应比父类方法的访问权限更大或相等。
    - 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。
    - 但是如果方法的返回值是引用类型（自造的类），重写时是可以返回该引用类型的子类的。

- ### 可变长参数：

  - ```java
    public void method1(String... args){...}
    public void method2(String arg1, String... args) {...}
    
    ```

  - 可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数

  - 遇到方法重载的情况:**会优先匹配固定参数,因为固定参数的方法匹配度更高。**

## 基本数据类型

- 八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 

- | 类型   | 基本数据类型 | 位数 | 字节 | 默认值  | 取值范围                                   |
  | ------ | :----------- | :--- | :--- | :------ | ------------------------------------------ |
  | 整数型 | `byte`       | 8    | 1    | 0       | -128 ~ 127                                 |
  | 整数型 | `short`      | 16   | 2    | 0       | -32768 ~ 32767                             |
  | 整数型 | `int`        | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
  | 整数型 | `long`       | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
  | 浮点型 | `float`      | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
  | 浮点型 | `double`     | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
  | 字符型 | `char`       | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
  | 布尔型 | `boolean`    | 1    |      | false   | true、false                                |

  - Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。

  - `char a = 'h'`char :单引号，`String a = "hello"` :双引号。

- ### 基本类型和包装类型的区别

  - 包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。

  - 包装类型可用于泛型，而基本类型不可以。

  - 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。

  - 相比于对象类型， 基本数据类型占用的空间非常小。
  - 基本数据类型的成员变量如果没有被 `static` 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。

- ### 包装类型的缓存机制

  - `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，
    - **所有整型包装类对象之间值的比较，全部使用 equals 方法比较**
  - `Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。
  - 两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制

- ### 自动装箱与拆箱

  - **装箱**：将基本类型用它们对应的引用类型包装起来；调用了 包装类的`valueOf()`方法

  - **拆箱**：将包装类型转换为基本数据类型；调用了 `xxxValue()`方法。 xxx为基本数据类型

  - ```java
    Integer i = 10;  //装箱
    int n = i;   //拆箱
    // Integer i = 10 等价于 Integer i = Integer.valueOf(10)
    // int n = i 等价于 int n = i.intValue();
    ```

  - **如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作**

    - ```java
      private static long sum() {
          Long sum = 0L;
          for (long i = 0; i <= Integer.MAX_VALUE; i++)
              sum += i;
          return sum;
      }
      ```





